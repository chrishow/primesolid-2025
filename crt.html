<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CRT TV Effect - WebGL</title>
  <style>
    html, body {
      margin: 0;
      background: #000;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .crt-container {
      position: relative;
      width: 640px; /* Match canvas size */
      height: 480px; /* Match canvas size */
      overflow: hidden;
      /* Optional: Add back border-radius if desired */
      /* border-radius: 50px; */
    }

    #crt-canvas {
      display: block; /* Prevent extra space below canvas */
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>

  <div class="crt-container">
    <!-- Canvas replaces the img tag -->
    <canvas id="crt-canvas" width="640" height="480"></canvas>
  </div>

  <!-- Vertex Shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec4 a_position; // Input vertex position (clip space)
    attribute vec2 a_texCoord; // Input texture coordinate
    varying vec2 v_texCoord;   // Pass texture coordinate to fragment shader
    void main() {
      gl_Position = a_position; // Use position directly (already in clip space)
      v_texCoord = a_texCoord;
    }
  </script>

  <!-- Fragment Shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 v_texCoord;     // Received texture coordinate
    uniform sampler2D u_texture; // The image texture
    uniform vec2 u_resolution;   // Resolution of the canvas

    // --- Bulge/Barrel Distortion ---
    // Adjust power > 0 for more bulge
    const float bulgeAmount = 0.2; // Positive for bulge, negative for pinch

    vec2 distort(vec2 p) {
        // Convert to center-based coords (-0.5 to 0.5)
        vec2 centered = p - 0.5;
        // Calculate distance from center, squared for efficiency
        float radiusSq = dot(centered, centered);
        // Apply distortion: Multiply coordinates by a factor > 1 based on distance
        // Factor = 1.0 + bulgeAmount * radiusSq
        vec2 distorted = centered * (1.0 + bulgeAmount * radiusSq);
        // Convert back to texture coords (0.0 to 1.0)
        return distorted + 0.5;
    }
    // --- End Distortion ---

    void main() {
      vec2 distortedCoords = distort(v_texCoord);

      // Sample the texture only if coords are within bounds
      if (distortedCoords.x >= 0.0 && distortedCoords.x <= 1.0 &&
          distortedCoords.y >= 0.0 && distortedCoords.y <= 1.0) {
        gl_FragColor = texture2D(u_texture, distortedCoords);
      } else {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black outside the bulge
      }
    }
  </script>

  <!-- WebGL Setup Script -->
  <script>
    function main() {
      const canvas = document.getElementById('crt-canvas');
      const gl = canvas.getContext('webgl');
      if (!gl) {
        alert('WebGL not supported');
        return;
      }

      // 1. Get shader source
      const vsSource = document.getElementById('vertex-shader').text;
      const fsSource = document.getElementById('fragment-shader').text;

      // 2. Compile shaders and link program
      const program = createProgram(gl, vsSource, fsSource);
      if (!program) return;

      // 3. Look up attribute and uniform locations
      const positionLocation = gl.getAttribLocation(program, 'a_position');
      const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
      const textureLocation = gl.getUniformLocation(program, 'u_texture');
      const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');

      // 4. Create buffers for a unit quad
      //    (2 triangles covering clip space -1 -> +1)
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,   // Triangle 1
         1, -1,
        -1,  1,
        -1,  1,   // Triangle 2
         1, -1,
         1,  1,
      ]), gl.STATIC_DRAW);

      const texCoordBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0, 0,    // Corresponds to -1, -1
        1, 0,    // Corresponds to  1, -1
        0, 1,    // Corresponds to -1,  1
        0, 1,    // Corresponds to -1,  1
        1, 0,    // Corresponds to  1, -1
        1, 1,    // Corresponds to  1,  1
      ]), gl.STATIC_DRAW);

      // 5. Load the image and create texture
      const texture = createTexture(gl);
      const image = new Image();
      image.src = 'src/i/test-card.jpg'; // Path to your image
      image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        // Set filtering after loading data
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        // Start rendering after image loads
        requestAnimationFrame(render);
      };
      image.onerror = () => {
          console.error("Failed to load image:", image.src);
          // Optionally draw a solid color or placeholder if image fails
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 255, 255])); // Magenta pixel
          requestAnimationFrame(render);
      }


      // --- Render Loop ---
      function render(time) {
        // Set viewport and clear
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Use the shader program
        gl.useProgram(program);

        // Bind position buffer
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Bind texture coordinate buffer
        gl.enableVertexAttribArray(texCoordLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

        // Set uniforms
        gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
        gl.uniform1i(textureLocation, 0); // Use texture unit 0

        // Activate texture unit 0 and bind the texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Draw the quad (6 vertices)
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        // Optional: Keep animating if needed, otherwise just draw once
        // requestAnimationFrame(render);
      }
    }

    // --- WebGL Helper Functions ---
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        return shader;
      }
      console.error('Shader compile error:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }

    function createProgram(gl, vsSource, fsSource) {
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      if (!vertexShader || !fragmentShader) return null;

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
        return program;
      }
      console.error('Program link error:', gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }

    function createTexture(gl) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      // Put a single pixel until image loads
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255])); // Black pixel
      return texture;
    }

    // Start the WebGL application
    main();
  </script>

</body>
</html>
